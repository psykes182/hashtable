
package de.hska.iwi.ads.solution.hashtable;

import de.hska.iwi.ads.dictionary.AbstractHashMap;
import de.hska.iwi.ads.dictionary.AbstractDictionary; // für DictionaryFullException

import java.util.Map;

public class Hashtable<K extends Comparable<K>, V> extends AbstractHashMap<K, V> {

    public Hashtable() {
        this(11);
    }

    public Hashtable(int capacity) {
        super(capacity); // Konstruktor aus AbstractHashtable
    }

    private static final class SimpleEntryImpl<K, V> implements Map.Entry<K, V> {
        private final K key;
        private V value;

        SimpleEntryImpl(K key, V value) {
            this.key = key;
            this.value = value;
        }

        @Override
        public K getKey() {
            return key;
        }

        @Override
        public V getValue() {
            return value;
        }

        @Override
        public V setValue(V newValue) {
            V old = this.value;
            this.value = newValue;
            return old;
        }
    }


    @Override
    @SuppressWarnings("unchecked")
    public V get(Object o) {
        if (o == null) {
            return null;
        }
        // Typ prüfen
        if (!(o instanceof Comparable)) {
            return null;
        }

        K key = (K) o; //Typecast

        int m = hashtable.length;
        if (m == 0) {
            return null;
        }

        int start = startIndex(key);

        for (int i = 0; i < m; i++) {
            int idx = probeIndex(start, i, m); //quadratisch sondieren Methode unten
            Map.Entry<K, V> entry = hashtable[idx];  //Eintrag am berechneten Index

            if (entry == null) {  //slot leer
                return null;
            }
            if (entry.getKey().equals(key)) {   //Treffer: Wert wird zurückgegeben
                return entry.getValue();
            }
        }

        // Nach kompletter Runde nichts gefunden
        return null;
    }

    @Override
    public V put(K key, V value) {
        if (key == null) {
            return null;
        }

        int m = hashtable.length;
        if (m == 0) {      //leere Liste -> kein Platz, exception
            throw new AbstractDictionary.DictionaryFullException();
        }

        int start = startIndex(key);


        for (int i = 0; i < m; i++) { //quadratisches Sondieren
            int idx = probeIndex(start, i, m);
            Map.Entry<K, V> entry = hashtable[idx];   //Eintrag ausgeben

            if (entry == null) {  //freier Behälter  -> einfügen
                hashtable[idx] = new SimpleEntryImpl<>(key, value);
                return null;
            }

            if (entry.getKey().equals(key)) {   //key existiert: Wert überschreiben, alten Wert ausgeben
                V old = entry.getValue();
                entry.setValue(value);
                return old;
            }
        }

        // kein freier Behälter gefunden -> Exception
        throw new AbstractDictionary.DictionaryFullException();
    }


    private int startIndex(K key) {
        int m = hashtable.length;
        return (key.hashCode() & 0x7fffffff) % m;
    }

    private int probeIndex(int start, int i, int m) {
        return ((start + i * i) % m);
    }
}

